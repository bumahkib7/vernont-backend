package com.vernont.application.order

import com.vernont.domain.order.dto.*
import com.vernont.domain.order.*
import com.vernont.events.OrderCreated
import com.vernont.events.OrderCompleted
import com.vernont.events.OrderCancelled
import com.vernont.events.EventPublisher
import com.vernont.repository.order.OrderRepository
import com.vernont.repository.order.OrderLineItemRepository
import com.vernont.repository.customer.CustomerRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageImpl
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import jakarta.validation.Valid
import java.math.BigDecimal

private val logger = KotlinLogging.logger {}

@Service
@Transactional
class OrderService(
    private val orderRepository: OrderRepository,
    private val orderLineItemRepository: OrderLineItemRepository,
    private val customerRepository: CustomerRepository,
    private val eventPublisher: EventPublisher
) {

    /**
     * Create a new order
     */
    fun createOrder(@Valid request: CreateOrderRequest): OrderResponse {
        logger.info { "Creating order for customer: ${request.customerId ?: request.email}" }

        // Validate customer exists if customerId provided
        val customer = request.customerId?.let { 
            customerRepository.findByIdAndDeletedAtIsNull(it)
                ?: throw CustomerNotFoundException("Customer not found: $it")
        }

        val order = Order().apply {
            customerId = request.customerId
            email = request.email
            cartId = request.cartId
            regionId = request.regionId
            currencyCode = request.currencyCode
            shippingMethodId = request.shippingMethodId
            paymentMethodId = request.paymentMethodId
            status = OrderStatus.PENDING
            fulfillmentStatus = FulfillmentStatus.NOT_FULFILLED
            paymentStatus = PaymentStatus.NOT_PAID

            // Set addresses if provided
            request.shippingAddress?.let {
                shippingAddress = OrderAddress().apply {
                    firstName = it.firstName
                    lastName = it.lastName
                    company = it.company
                    phone = it.phone
                    address1 = it.address1
                    address2 = it.address2
                    city = it.city
                    province = it.province
                    postalCode = it.postalCode
                    countryCode = it.countryCode
                }
            }

            request.billingAddress?.let {
                billingAddress = OrderAddress().apply {
                    firstName = it.firstName
                    lastName = it.lastName
                    company = it.company
                    phone = it.phone
                    address1 = it.address1
                    address2 = it.address2
                    city = it.city
                    province = it.province
                    postalCode = it.postalCode
                    countryCode = it.countryCode
                }
            }
        }

        // Set initial display ID (will be auto-generated by database)
        val savedOrder = orderRepository.save(order)

        // Create line items
        request.items.forEach { itemRequest ->
            val lineItem = OrderLineItem().apply {
                this.order = savedOrder
                variantId = itemRequest.variantId
                title = itemRequest.title
                description = itemRequest.description
                thumbnail = itemRequest.thumbnail
                quantity = itemRequest.quantity
                currencyCode = itemRequest.currencyCode
                unitPrice = itemRequest.unitPrice
                discount = itemRequest.discount
                isGiftcard = itemRequest.isGiftcard
                allowDiscounts = itemRequest.allowDiscounts
                hasShipping = itemRequest.hasShipping
                // Total will be calculated when order is saved
            }
            orderLineItemRepository.save(lineItem)
            savedOrder.items.add(lineItem)
        }

        // Recalculate order totals
        savedOrder.recalculateTotals()
        val finalOrder = orderRepository.save(savedOrder)

        eventPublisher.publish(
            OrderCreated(
                aggregateId = finalOrder.id,
                customerId = finalOrder.customerId ?: "",
                items = finalOrder.items.map {
                    com.vernont.events.OrderItem(
                        productId = it.variantId ?: "",
                        quantity = it.quantity,
                        unitPrice = it.unitPrice,
                        totalPrice = it.total
                    )
                },
                totalAmount = finalOrder.total,
                shippingAddress = finalOrder.shippingAddress?.getFullAddress() ?: "",
                status = finalOrder.status.name
            )
        )

        logger.info { "Order created successfully: ${finalOrder.id}" }
        return OrderResponse.from(finalOrder)
    }

    /**
     * Update order
     */
    fun updateOrder(orderId: String, @Valid request: UpdateOrderRequest): OrderResponse {
        logger.info { "Updating order: $orderId" }

        val order = orderRepository.findByIdAndDeletedAtIsNull(orderId)
            ?: throw OrderNotFoundException("Order not found: $orderId")

        // Only allow updates for pending orders
        if (order.status !in listOf(OrderStatus.PENDING)) {
            throw OrderUpdateNotAllowedException("Cannot update order in status: ${order.status}")
        }

        order.apply {
            request.email?.let { email = it }
            request.shippingMethodId?.let { shippingMethodId = it }
            request.paymentMethodId?.let { paymentMethodId = it }
        }

        val updated = orderRepository.save(order)

        logger.info { "Order updated successfully: $orderId" }
        return OrderResponse.from(updated)
    }

    /**
     * Get order by ID
     */
    @Transactional(readOnly = true)
    fun getOrder(orderId: String): OrderResponse {
        val order = orderRepository.findByIdAndDeletedAtIsNull(orderId)
            ?: throw OrderNotFoundException("Order not found: $orderId")

        return OrderResponse.from(order)
    }

    /**
     * Get order by display ID
     */
    @Transactional(readOnly = true)
    fun getOrderByDisplayId(displayId: Int): OrderResponse {
        val order = orderRepository.findByDisplayIdAndDeletedAtIsNull(displayId)
            ?: throw OrderNotFoundException("Order not found with display ID: $displayId")

        return OrderResponse.from(order)
    }

    /**
     * List orders for customer by customerId only (legacy method)
     */
    @Transactional(readOnly = true)
    fun listCustomerOrders(customerId: String, pageable: Pageable): Page<OrderSummaryResponse> {
        val orders = orderRepository.findAllByCustomerIdAndDeletedAtIsNull(customerId)
        val summaries = orders.map { OrderSummaryResponse.from(it) }

        val start = pageable.offset.toInt()
        val end = minOf(start + pageable.pageSize, summaries.size)
        val pageContent = if (start < summaries.size) summaries.subList(start, end) else emptyList()

        return PageImpl(pageContent, pageable, summaries.size.toLong())
    }

    /**
     * List orders for customer by customerId OR email.
     * This includes orders placed as guest before registration.
     */
    @Transactional(readOnly = true)
    fun listCustomerOrdersByIdOrEmail(customerId: String, email: String, pageable: Pageable): Page<OrderSummaryResponse> {
        logger.debug { "Fetching orders for customerId: $customerId or email: $email" }

        val orders = orderRepository.findAllByCustomerIdOrEmailAndDeletedAtIsNull(customerId, email)
        val summaries = orders.map { OrderSummaryResponse.from(it) }

        val start = pageable.offset.toInt()
        val end = minOf(start + pageable.pageSize, summaries.size)
        val pageContent = if (start < summaries.size) summaries.subList(start, end) else emptyList()

        logger.debug { "Found ${summaries.size} orders for customer" }
        return PageImpl(pageContent, pageable, summaries.size.toLong())
    }

    /**
     * Link all guest orders (orders without customerId) to a customer by email.
     * This should be called when a customer registers to claim their previous orders.
     * Returns the number of orders linked.
     */
    fun linkGuestOrdersToCustomer(customerId: String, email: String): Int {
        logger.info { "Linking guest orders for email: $email to customer: $customerId" }

        val linkedCount = orderRepository.linkGuestOrdersToCustomer(customerId, email)

        if (linkedCount > 0) {
            logger.info { "Successfully linked $linkedCount guest orders to customer: $customerId" }
        } else {
            logger.debug { "No guest orders found to link for email: $email" }
        }

        return linkedCount
    }

    /**
     * List all orders with pagination
     */
    @Transactional(readOnly = true)
    fun listOrders(pageable: Pageable): Page<OrderSummaryResponse> {
        return orderRepository.findAll(pageable)
            .map { OrderSummaryResponse.from(it) }
    }

    /**
     * List orders by status
     */
    @Transactional(readOnly = true)
    fun listOrdersByStatus(status: OrderStatus): List<OrderSummaryResponse> {
        return orderRepository.findByStatusAndDeletedAtIsNull(status)
            .map { OrderSummaryResponse.from(it) }
    }

    /**
     * Cancel order
     */
    fun cancelOrder(orderId: String, reason: String? = null): OrderResponse {
        logger.info { "Cancelling order: $orderId" }

        val order = orderRepository.findByIdAndDeletedAtIsNull(orderId)
            ?: throw OrderNotFoundException("Order not found: $orderId")

        // Check if order can be cancelled
        if (order.status in listOf(OrderStatus.COMPLETED, OrderStatus.CANCELED)) {
            throw OrderCancellationNotAllowedException("Cannot cancel order in status: ${order.status}")
        }

        order.cancel()
        val cancelled = orderRepository.save(order)

        eventPublisher.publish(
            OrderCancelled(
                aggregateId = orderId,
                customerId = order.customerId ?: "",
                reason = reason ?: "Cancelled by user",
                refundAmount = order.total
            )
        )

        logger.info { "Order cancelled successfully: $orderId" }
        return OrderResponse.from(cancelled)
    }

    /**
     * Complete order
     */
    fun completeOrder(orderId: String): OrderResponse {
        logger.info { "Completing order: $orderId" }

        val order = orderRepository.findByIdAndDeletedAtIsNull(orderId)
            ?: throw OrderNotFoundException("Order not found: $orderId")

        if (order.status != OrderStatus.PENDING) {
            throw OrderCompletionNotAllowedException("Cannot complete order in status: ${order.status}")
        }

        order.complete()
        val completed = orderRepository.save(order)

        eventPublisher.publish(
            OrderCompleted(
                aggregateId = orderId,
                customerId = order.customerId ?: "",
                totalAmount = order.total,
                completedAt = completed.updatedAt
            )
        )

        logger.info { "Order completed successfully: $orderId" }
        return OrderResponse.from(completed)
    }

    /**
     * Update order payment status with validation
     */
    fun updatePaymentStatus(orderId: String, paymentStatus: PaymentStatus): OrderResponse {
        logger.info { "Updating payment status for order: $orderId to $paymentStatus" }

        val order = orderRepository.findByIdAndDeletedAtIsNull(orderId)
            ?: throw OrderNotFoundException("Order not found: $orderId")

        // Validate payment status transition
        val validTransitions = getValidPaymentStatusTransitions(order.paymentStatus)
        if (paymentStatus !in validTransitions) {
            throw OrderUpdateNotAllowedException(
                "Invalid payment status transition from ${order.paymentStatus} to $paymentStatus"
            )
        }

        order.paymentStatus = paymentStatus
        val updated = orderRepository.save(order)

        logger.info { "Payment status updated for order: $orderId" }
        return OrderResponse.from(updated)
    }

    /**
     * Update order fulfillment status with validation
     */
    fun updateFulfillmentStatus(orderId: String, fulfillmentStatus: FulfillmentStatus): OrderResponse {
        logger.info { "Updating fulfillment status for order: $orderId to $fulfillmentStatus" }

        val order = orderRepository.findByIdAndDeletedAtIsNull(orderId)
            ?: throw OrderNotFoundException("Order not found: $orderId")

        // Validate fulfillment status transition
        val validTransitions = getValidFulfillmentStatusTransitions(order.fulfillmentStatus)
        if (fulfillmentStatus !in validTransitions) {
            throw OrderUpdateNotAllowedException(
                "Invalid fulfillment status transition from ${order.fulfillmentStatus} to $fulfillmentStatus"
            )
        }

        order.fulfillmentStatus = fulfillmentStatus
        val updated = orderRepository.save(order)

        logger.info { "Fulfillment status updated for order: $orderId" }
        return OrderResponse.from(updated)
    }

    private fun getValidPaymentStatusTransitions(current: PaymentStatus): Set<PaymentStatus> {
        return when (current) {
            PaymentStatus.NOT_PAID -> setOf(PaymentStatus.AWAITING, PaymentStatus.CAPTURED, PaymentStatus.REQUIRES_ACTION)
            PaymentStatus.AWAITING -> setOf(PaymentStatus.CAPTURED, PaymentStatus.NOT_PAID, PaymentStatus.CANCELED)
            PaymentStatus.REQUIRES_ACTION -> setOf(PaymentStatus.CAPTURED, PaymentStatus.CANCELED, PaymentStatus.NOT_PAID)
            PaymentStatus.PARTIALLY_PAID -> setOf(PaymentStatus.PAID, PaymentStatus.CANCELED)
            PaymentStatus.PAID -> setOf(PaymentStatus.PARTIALLY_REFUNDED, PaymentStatus.REFUNDED)
            PaymentStatus.CAPTURED -> setOf(PaymentStatus.PARTIALLY_REFUNDED, PaymentStatus.REFUNDED)
            PaymentStatus.PARTIALLY_REFUNDED -> setOf(PaymentStatus.REFUNDED)
            PaymentStatus.REFUNDED -> emptySet() // Terminal state
            PaymentStatus.CANCELED -> emptySet() // Terminal state
        }
    }

    private fun getValidFulfillmentStatusTransitions(current: FulfillmentStatus): Set<FulfillmentStatus> {
        return when (current) {
            FulfillmentStatus.NOT_FULFILLED -> setOf(FulfillmentStatus.PARTIALLY_FULFILLED, FulfillmentStatus.FULFILLED)
            FulfillmentStatus.PARTIALLY_FULFILLED -> setOf(FulfillmentStatus.FULFILLED, FulfillmentStatus.PARTIALLY_SHIPPED)
            FulfillmentStatus.FULFILLED -> setOf(FulfillmentStatus.SHIPPED, FulfillmentStatus.PARTIALLY_SHIPPED)
            FulfillmentStatus.PARTIALLY_SHIPPED -> setOf(FulfillmentStatus.SHIPPED)
            FulfillmentStatus.SHIPPED -> setOf(FulfillmentStatus.CANCELED, FulfillmentStatus.RETURNED, FulfillmentStatus.PARTIALLY_RETURNED)
            FulfillmentStatus.PARTIALLY_RETURNED -> setOf(FulfillmentStatus.RETURNED)
            FulfillmentStatus.RETURNED -> emptySet() // Terminal state
            FulfillmentStatus.CANCELED -> emptySet() // Terminal state
            FulfillmentStatus.REQUIRES_ACTION -> setOf(FulfillmentStatus.FULFILLED, FulfillmentStatus.CANCELED)
        }
    }

    /**
     * Update line item quantity
     */
    fun updateLineItemQuantity(orderId: String, lineItemId: String, quantity: Int): OrderResponse {
        logger.info { "Updating line item quantity: $lineItemId in order: $orderId" }

        val order = orderRepository.findWithItemsByIdAndDeletedAtIsNull(orderId)
            ?: throw OrderNotFoundException("Order not found: $orderId")

        if (order.status !in listOf(OrderStatus.PENDING)) {
            throw OrderUpdateNotAllowedException("Cannot modify order in status: ${order.status}")
        }

        val lineItem = order.items.find { it.id == lineItemId }
            ?: throw OrderLineItemNotFoundException("Line item not found: $lineItemId")

        lineItem.quantity = quantity
        lineItem.recalculateTotal()

        orderLineItemRepository.save(lineItem)
        order.recalculateTotals()
        val updated = orderRepository.save(order)

        logger.info { "Line item quantity updated successfully: $lineItemId" }
        return OrderResponse.from(updated)
    }

    /**
     * Get order statistics
     */
    @Transactional(readOnly = true)
    fun getOrderStatistics(): OrderStatistics {
        val totalOrders = orderRepository.count()
        val pendingCount = orderRepository.countByStatus(OrderStatus.PENDING)
        val completedCount = orderRepository.countByStatus(OrderStatus.COMPLETED)
        val cancelledCount = orderRepository.countByStatus(OrderStatus.CANCELED)
        val totalRevenue = orderRepository.sumTotalByStatus(OrderStatus.COMPLETED) ?: BigDecimal.ZERO

        return OrderStatistics(
            totalOrders = totalOrders,
            pendingOrders = pendingCount,
            completedOrders = completedCount,
            cancelledOrders = cancelledCount,
            totalRevenue = totalRevenue
        )
    }
}

/**
 * Order statistics data class
 */
data class OrderStatistics(
    val totalOrders: Long,
    val pendingOrders: Long,
    val completedOrders: Long,
    val cancelledOrders: Long,
    val totalRevenue: BigDecimal
)

// Exception classes
class OrderNotFoundException(message: String) : RuntimeException(message)
class OrderUpdateNotAllowedException(message: String) : RuntimeException(message)
class OrderCancellationNotAllowedException(message: String) : RuntimeException(message)
class OrderCompletionNotAllowedException(message: String) : RuntimeException(message)
class OrderLineItemNotFoundException(message: String) : RuntimeException(message)
class CustomerNotFoundException(message: String) : RuntimeException(message)