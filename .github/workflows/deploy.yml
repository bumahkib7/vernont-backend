name: Deploy Backend to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  AWS_REGION: eu-north-1
  ECR_REPOSITORY: 459722925345.dkr.ecr.eu-north-1.amazonaws.com/vernont-backend
  EB_APPLICATION_NAME: vernont-backend
  EB_ENVIRONMENT_PROD: vernont-prod
  EB_ENVIRONMENT_STAGING: vernont-staging

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 25
        uses: actions/setup-java@v4
        with:
          java-version: '25'
          distribution: 'corretto'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image tag
        id: image-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${TIMESTAMP}-${SHORT_SHA}"
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image with Jib
        env:
          JIB_TO_IMAGE: ${{ steps.image-tag.outputs.full_image }}
        run: |
          ./gradlew :vernont-api:jib \
            --image="${JIB_TO_IMAGE}" \
            -Djib.to.tags=latest,${{ steps.image-tag.outputs.tag }} \
            -Djib.console=plain \
            --no-daemon

      - name: Determine environment name
        id: env-name
        run: |
          if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
            echo "name=${{ env.EB_ENVIRONMENT_STAGING }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ env.EB_ENVIRONMENT_PROD }}" >> $GITHUB_OUTPUT
          fi

      - name: Create Dockerrun.aws.json
        run: |
          cat > Dockerrun.aws.json <<EOF
          {
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "${{ steps.image-tag.outputs.full_image }}",
              "Update": "true"
            },
            "Ports": [
              {
                "ContainerPort": 8080,
                "HostPort": 8080
              }
            ],
            "Logging": "/var/log/nginx"
          }
          EOF

      - name: Create deployment package
        run: zip -q deployment.zip Dockerrun.aws.json

      - name: Upload to S3
        id: s3-upload
        run: |
          VERSION_LABEL="vernont-${{ steps.image-tag.outputs.tag }}"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          S3_BUCKET="elasticbeanstalk-${{ env.AWS_REGION }}-${ACCOUNT_ID}"
          S3_KEY="vernont-backend/${VERSION_LABEL}.zip"

          aws s3 cp deployment.zip "s3://${S3_BUCKET}/${S3_KEY}"

          echo "version_label=${VERSION_LABEL}" >> $GITHUB_OUTPUT
          echo "s3_bucket=${S3_BUCKET}" >> $GITHUB_OUTPUT
          echo "s3_key=${S3_KEY}" >> $GITHUB_OUTPUT

      - name: Create application version
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name "${{ env.EB_APPLICATION_NAME }}" \
            --version-label "${{ steps.s3-upload.outputs.version_label }}" \
            --source-bundle "S3Bucket=${{ steps.s3-upload.outputs.s3_bucket }},S3Key=${{ steps.s3-upload.outputs.s3_key }}" \
            --no-auto-create-application || true

      - name: Wait for environment to be ready
        run: |
          ENV_NAME="${{ steps.env-name.outputs.name }}"
          MAX_WAIT=300
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws elasticbeanstalk describe-environments \
              --environment-names "$ENV_NAME" \
              --query 'Environments[0].Status' \
              --output text 2>/dev/null || echo "Unknown")

            if [ "$STATUS" = "Ready" ]; then
              echo "Environment is ready"
              break
            elif [ "$STATUS" = "Updating" ] || [ "$STATUS" = "Launching" ]; then
              echo "Environment is ${STATUS}... waiting (${ELAPSED}s elapsed)"
              sleep 15
              ELAPSED=$((ELAPSED + 15))
            else
              echo "Environment status: ${STATUS}"
              break
            fi
          done

      - name: Deploy to Elastic Beanstalk
        run: |
          aws elasticbeanstalk update-environment \
            --environment-name "${{ steps.env-name.outputs.name }}" \
            --version-label "${{ steps.s3-upload.outputs.version_label }}"

      - name: Wait for deployment to complete
        run: |
          ENV_NAME="${{ steps.env-name.outputs.name }}"
          MAX_WAIT=600
          ELAPSED=0

          echo "Waiting for deployment to complete..."
          sleep 30  # Initial wait

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws elasticbeanstalk describe-environments \
              --environment-names "$ENV_NAME" \
              --query 'Environments[0].Status' \
              --output text)

            HEALTH=$(aws elasticbeanstalk describe-environments \
              --environment-names "$ENV_NAME" \
              --query 'Environments[0].Health' \
              --output text)

            echo "Status: ${STATUS}, Health: ${HEALTH} (${ELAPSED}s elapsed)"

            if [ "$STATUS" = "Ready" ]; then
              if [ "$HEALTH" = "Green" ] || [ "$HEALTH" = "Yellow" ]; then
                echo "Deployment successful!"
                exit 0
              fi
            fi

            sleep 30
            ELAPSED=$((ELAPSED + 30))
          done

          echo "Deployment timeout or failed"
          exit 1

      - name: Deployment summary
        if: always()
        run: |
          echo "========================================"
          echo "         Deployment Summary             "
          echo "========================================"
          echo "Environment: ${{ steps.env-name.outputs.name }}"
          echo "Version: ${{ steps.s3-upload.outputs.version_label }}"
          echo "Image: ${{ steps.image-tag.outputs.full_image }}"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "AWS Console:"
          echo "https://${{ env.AWS_REGION }}.console.aws.amazon.com/elasticbeanstalk/home?region=${{ env.AWS_REGION }}#/environment/dashboard?environmentName=${{ steps.env-name.outputs.name }}"

      - name: Cleanup
        if: always()
        run: rm -f Dockerrun.aws.json deployment.zip
